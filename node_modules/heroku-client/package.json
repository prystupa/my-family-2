{
  "name": "heroku-client",
  "version": "0.9.2",
  "description": "A wrapper for the Heroku v3 API",
  "main": "./lib/heroku.js",
  "scripts": {
    "test": "./node_modules/jasmine-node/bin/jasmine-node spec"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/heroku/node-heroku-client"
  },
  "keywords": [
    "heroku"
  ],
  "author": {
    "name": "Jonathan Clem"
  },
  "license": "MIT",
  "bugs": {
    "url": "https://github.com/heroku/node-heroku-client/issues"
  },
  "devDependencies": {
    "jasmine-node": "~1.11.0"
  },
  "dependencies": {
    "q": "~0.9.6",
    "memjs": "~0.6.0",
    "inflection": "~1.2.6"
  },
  "readme": "# heroku-client [![Build Status](https://travis-ci.org/heroku/node-heroku-client.png?branch=master)](https://travis-ci.org/heroku/node-heroku-client)\n\nA wrapper around the [v3 Heroku API][platform-api-reference].\n\n## Install\n\n```sh\n$ npm install heroku-client --save\n```\n\n## Documentation\n\nDocs are auto-generated and live in the [docs directory](https://github.com/heroku/node-heroku-client/tree/development/docs).\n\n## Usage\n\n`heroku-client` works by providing functions that return proxy objects for\ninteracting with different resources through the Heroku API.\n\nTo begin, require the Heroku module and create a client, passing in an API\ntoken:\n\n```javascript\nvar Heroku = require('heroku-client'),\n    heroku = new Heroku({ token: process.env.HEROKU_API_TOKEN });\n```\n\nThe simplest example is listing a user's apps. First, we call `heroku.apps()`,\nwhich returns a proxy object to the /apps endpoint, then we call `list()` to\nactually perform the API call:\n\n```javascript\nheroku.apps().list(function (err, apps) {\n  // `apps` is a parsed JSON response from the API\n});\n```\n\nThe advantage of using proxy objects is that they are reusable. Let's get the\ninfo for the user's app \"my-app\", get the dynos for the app, and\nremove a collaborator:\n\n```javascript\nvar app = heroku.apps('my-app');\n\napp.info(function (err, app) {\n  // Details about the `app`\n});\n\napp.dynos().list(function (err, dynos) {\n  // List of the app's `dynos`\n});\n\napp.collaborators('user@example.com').delete(function (err, collaborator) {\n  // The `collaborator` has been removed unless `err`\n});\n```\n\nRequests that require a body are easy, as well. Let's add a collaborator to\nthe user's app \"another-app\":\n\n```javascript\nvar app  = heroku.apps('another-app'),\n    user = { email: 'new-user@example.com' };\n\napp.collaborators().create({ user: user }, function (err, collaborator) {\n  // `collaborator` is the newly added collaborator unless `err`\n});\n```\n\n### Generic Requests\n\nheroku-client has `get`, `post`, `patch`, and `delete` functions which can make requests with the specified HTTP method to any endpoint:\n\n```javascript\nheroku.get('/apps', function (err, apps) {\n});\n\n// Request body is optional on both `post` and `patch`\nheroku.post('/apps', function (err, app) {\n});\n\nheroku.post('/apps', { name: 'my-new-app' }, function (err, app) {\n});\n\nheroku.patch('/apps/my-app', { name: 'my-renamed-app' }, function (err, app) {\n});\n\nheroku.delete('/apps/my-old-app', function (err, app) {\n});\n```\n\nThere is also an even more generic `request` function that can accept many more options:\n\n```javascript\nheroku.request({\n  method: 'GET',\n  path: '/apps',\n  headers: {\n    'Foo': 'Bar'\n  }\n}, function (err, responseBody) {\n});\n```\n\n### Promises\n\nheroku-client works with Node-style callbacks, but also implements promises with the [Q][q] library.\n\n```javascript\nvar q = require('q');\n\n// Fetches dynos for all of my apps.\nheroku.apps().list().then(function (apps) {\n\n  return q.all(apps.map(function (app) {\n    return heroku.apps(app.name).dynos().list();\n  }));\n\n}).then(function (dynos) {\n\n  console.log(dynos);\n\n});\n```\n\n## Caching\n\nheroku-client performs caching by creating a memcached client using [memjs][memjs]. See the memjs repo for environment-specific configuration instructions and details.\n\nheroku-client will cache any response from the Heroku API that comes with an `ETag` header, and each response is cached individually (i.e. even though the client might make multiple calls for a user's apps and then aggregate them into a single JSON array, each required API call is individually cached). For each API request it performs, heroku-client sends an `If-None-Match` header if there is a cached response for the API request. If API returns a 304 response code, heroku-client returns the cached response. Otherwise, it writes the new API response to the cache and returns that.\n\nTo tell heroku-client to perform caching, call the `configure` function:\n\n```javascript\nvar Heroku = require('heroku').configure({ cache: true });\n```\n\nThis requires a `MEMCACHIER_SERVERS` environment variable, as well as a `HEROKU_CLIENT_ENCRYPTION_SECRET` environment variable that heroku-client uses to build cache keys and encrypt cache contents.\n\n`HEROKU_CLIENT_ENCRYPTION_SECRET` should be a long, random string of characters. heroku-client includes [`bin/secret`][bin_secret] as one way of generating values for this variable. **Do not publish this secret or commit it to source control. If it's compromised, flush your memcache and generate a new encryption secret.**\n\n`MEMCACHIER_SERVERS` can be a single `hostname:port` memache address, or a comma-separated list of memcache addresses, e.g. `example.com:11211,example.net:11211`. Note that while the environment variable that memjs looks for is [named for the MemCachier service it was originally built for][memcachier], it will work with any memcache server that speaks the binary protocol.\n\n## Contributing\n\n### Updating resources\n\nWhen a new resource manifest is available, download it into the repo, run tests, generate documentation, and [bump the version number accordingly](http://semver.org/).\n\n### Generating documentation\n\nDocumentation for heroku-client is auto-generated from [the resources manifest](https://github.com/heroku/node-heroku-client/blob/development/lib/resources.js).\nDocs are generated like so:\n\n```bash\n$ bin/docs\n```\n\nGenerating docs also runs a cursory test, ensuring that every documented function *is* a function that can be called.\n\n### Running tests\n\nheroku-client uses [jasmine-node][jasmine-node] for tests:\n\n```bash\n$ npm test\n```\n\n[platform-api-reference]: https://devcenter.heroku.com/articles/platform-api-reference\n[q]: https://github.com/kriskowal/q\n[memjs]: https://github.com/alevy/memjs\n[bin_secret]: https://github.com/heroku/node-heroku-client/blob/development/bin/secret\n[memcachier]: https://www.memcachier.com\n[jasmine-node]: https://github.com/mhevery/jasmine-node\n",
  "readmeFilename": "README.md",
  "_id": "heroku-client@0.9.2",
  "dist": {
    "shasum": "c2d6355ff0c9e19f0a97c5943fdf523e08ca90ac"
  },
  "_from": "heroku-client@~0.9.2",
  "_resolved": "https://registry.npmjs.org/heroku-client/-/heroku-client-0.9.2.tgz"
}
